# Бройни системи.<br>Побитови операции

<slidebreak/>

## Бройни системи

- Начин за представяне на числата - количествена характеристика - брой
- Има позиционни бройни системи, които имат теглова стойност за всяка цифра от числото в последователността, а при непозиционните има други правила например за последователността на цифрите като при римската бройна система
- Всяка бройна система се характеризира с основа - броят унакилани символи, с които се записват числата - още азбука на бройната система
- Приемаме че бройната система има за основа естествено ненулево число, въпреки че има и изключения
- Най-разпространени по различни причини са бройните системи с основа 2,8,10,16,20,60,64
- Азбуката на бройната система може да е произволна

<slidebreak/>

- При позиционните бройни системи обкновено отляво надясно цифрите на всяка позиция се умножават с тегло $n^p$, където $n$ e основата на системата, а $p$ е текущата цифра отдясно наляво, индексирана от 0
- Тоест числото $a = a_ka_{k-1} \cdots a_1a_0$ в n-ична бройна система ще има стойност в десетична $\sum_{j=0}^k f(a_j) \cdot n^j$, където $f(x)$ e десетичната стойност на цифрата x от дадената бройна система
- Наример за работа с позиционна бройна система с основа 3 и азбука `'A', 'K', '7'` - семантично означаващи стойности в 10-тична система 0,1,2 - числото `7A` преобразуване към десетична система ще има стойност `6 = 2*3^1 + 0*3^0`. Как образуваме последователни числа? - Когато за дадена позици сме обходили всички възможни цифрени стойности, започваме следващата цифрена стойност, като за една нейна итерация обхождаме всички възможни цифрени стойности на всички предходни позиции

<slidebreak/>

| Десетична (decimal) | Двоична (binary) | осмична (octal) | Шестнайсетична (hexadecimal) |
| ------------------- | ---------------- | --------------- | ---------------------------- |
| 0-9                 | 0-1              | 0-7             | 0-F (0-9 & A-F)              |
| 00                  | 00000            | 00              | 00                           |
| 01                  | 00001            | 01              | 01                           |
| 02                  | 00010            | 02              | 02                           |
| 03                  | 00011            | 03              | 03                           |
| 04                  | 00100            | 04              | 04                           |
| 05                  | 00101            | 05              | 05                           |
| 06                  | 00110            | 06              | 06                           |
| 07                  | 00111            | 07              | 07                           |
| 08                  | 01000            | 10              | 08                           |
| 09                  | 01001            | 11              | 09                           |
| 10                  | 01010            | 12              | 0A                           |
| 11                  | 01011            | 13              | 0B                           |
| 12                  | 01100            | 14              | 0C                           |
| 13                  | 01101            | 15              | 0D                           |

<slidebreak/>

- За преобразуване от система в система винаги делим целочислено числото до достигане на нула на число със стойност равна на основана на новата система и взимаме остатъците в обратен ред
- За удобство ако искаме да сметнем десетичната стойност на дадено число може да умножим всяка позиция по

- За работа при преобразуване между произволни бройни системи е удобно да се ползва преминаване между десетична бройна система

- Операциите по делене, умножение, изваждане и събиране могат да са объркващи ако искаме да ги приложим над две произволни системи директно, но в общия случай правилата са еднакви

- Например $2143_5 = 640_7$, понеже $7 = 12_5$ и имаме
  - $2143_5 / 12_5 = 132_5 (4_5 = 4_7)$
  - $132_5 / 12_5 = 11_5 (0_5 = 0_7)$
  - $11_5 / 12_5 = 0_5 (11_5 = 6_7)$

<slidebreak/>

```cpp
// TODO: there are no validations in this example!

const size_t MAX_DIGITS = 1024;

void swap(char& x, char& y)
{
    char temp = x;
    x = y;
    y = temp;
}

int indexOf(char c, char arr[], size_t count)
{
    for (size_t i = 0; i < count; i++)
    {
        if (arr[i] == c)
        {
            return i;
        }
    }

    return -1;
}

void reverseArray(char arr[], size_t count)
{
    for (size_t i = 0; i < count / 2; i++)
    {
        swap(arr[i], arr[count - i - 1]);
    }
}

int fromNto10(char number[], int digitsCount, int n, char nAlphabet[]) {
    int result = 0;
    for (size_t i = 0; i < digitsCount; i++)
    {
        result *= n;
        result += indexOf(number[i], nAlphabet, n);
    }
    return result;
}

size_t from10toN(int number, int n, char nAlphabet[], char result[]) {

    size_t digitsCount = 0;
    while (number)
    {
        result[digitsCount++] = nAlphabet[number % n];
        number /= n;
    }

    reverseArray(result, digitsCount);
    return digitsCount;
}

size_t convertNBaseToKBase(char number[], size_t digitsCount, char result[], size_t n, char nAlphabet[], size_t k, char kAlphabet[])
{
    return from10toN(fromNto10(number, digitsCount, n, nAlphabet), k, kAlphabet, result);
}
```

<slidebreak/>

- Представяне на отрицателни числа
- 1's compliment: flip the number (e.g. 1011 -> 0100)  - flaw: zero = 00...000 = 11...111
- 2's compliment: flip the number and add 1 (e.g. 1011 -> 0100 -> 0101) - zero = 00...000
- Когато използваме 2's compliment печелим едно допълнително отрицателно число (11...111)

<slidebreak/>

## Побитови оператори

| Оператор | Значение | Тип |
| :---: | :---: | :---: |
| `&` | Побитово **и** | инфиксен, бинарен|
| `\|` | Побитово **или** | инфиксен, бинарен|
| `~` | Побитово **не** | префиксен, унарен|
| `<<` | Побитове отместване наляво | инфиксен, бинарен|
| `>>` | Логическо отместване надясно | инфиксен, бинарен|


```cpp
int x = 7;     // 0b110
int y = 5;     // 0b101
int op1 = x&y; // 0b100
int op2 = x|y; // 0b111
int op3 = ~x;  // 0b001
int op4 = x<<2;// 0b11000
int op5 = x>>2;// 0b1__
```
<slidebreak/>

- Основни побитови операции
    - Проверка дали число е четно
    - Пресмянане 2 на степен k
    - Взимане на стойност на бит
    - Задаване на стойлност на бит
    - Toggle на бит

<slidebreak/>

- Основни приложения
    - Четност на срещане на число (свойство на XOR)
    - Подмножества - генериране на индикаторна функция (свойство на последователните двоични числа)
    - Оптимизация на мястото за съхранение - напр. съхранение на булева информация
