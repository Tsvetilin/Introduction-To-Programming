# Видове сортиране - https://visualgo.net/en/sorting?slide=1-1

- Bubble sort
- Selection sort
- Insertion sort

# Търсене на елемент в сортиран масив

- Binary search

### Bubble sort

```c++
void bubbleSort(int arr[], int n)
{
    int i, j;
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```

### Selection sort

```c++
void selectionSort(int arr[], int n)
{
    int i, j, min_idx;
 
    for (i = 0; i < n - 1; i++) {
 
        min_idx = i;
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx])
                min_idx = j;
        }
 
        if (min_idx != i)
            swap(arr[min_idx], arr[i]);
    }
}
```

### Insertion sort

```c++
void insertionSort(int arr[], int n)
{
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
 
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
```

### Binary search

```c++
int binarySearch(int arr[], int l, int r, int x)
{
    while (l <= r) {
        int m = l + (r - l) / 2;
 
        // Check if x is present at mid
        if (arr[m] == x)
            return m;
 
        // If x greater, ignore left half
        if (arr[m] < x)
            l = m + 1;
 
        // If x is smaller, ignore right half
        else
            r = m - 1;
    }
 
    // If we reach here, then element was not present
    return -1;
}
```

# Задачи, максималният размер да е 1000

### **1.**  Напишете функция, която приема масив от цели числа и индекс и премахва числото, което се намира на този индекс.

Вход:

```
[33 1 23 8 54 5 1 6] 3
```

Изход:

```
[33 1 23 54 5 1 6]
```

### **2.** Напишете функция, която приема 2 масива от цели числа **arr** и  **result** (който е празен), 2 числа **a** и **b**  и пълни масива **result** с всички числа от  **arr**, които са  в  интервала **[a, b]** .

Вход:

```
[5 7 1 4 3 9 10]
2 8
```

Изход:

```
[1 4 3 9 10]
```

### **3.** Да се напише функция, която приема масив от цели числа и връща дали е симетричен.

Вход:

```
[1 2 3 2 1]
```

Изход:

```
yes
```

Вход:

```
[1 2 3 4 1]
```

Изход:

```
no
```

### **4.** Да се напише функция, която приема масив от цели числа и връща дължината на най-дългата редица от еднакви числа.

**Пример:**

Вход:

```c++
[3 3 2 2 2 5 2 2 3 3 3]
```

Изход:

```c++
3
```
### **5.** Напишете функция, която приема масив от цели числа и филтрира отрицателните елементи от масива, като ги премахва.

**Пример:**
```c++
[1, -4, 4, -5, -9, 2, 10]
```
```c++
[1, 4, 2, 10]
```


### **6.** Напишете функция, която приема два масива от цели числа и размерите им, и проверява дали вторият масив е подмасив на първия.

Вход:
```c++
[1, 4, 4, 0, 4, 2]
[4, 0, 4]
```

Изход:
```c++
true
```

Вход:
```c++
[1, 4, 9, 8, 4, 2]
[4, 9, 2]
```

Изход:
```c++
false
```

### **7.** Да се напише функция, която приема 3 масива от цели числа - arr1, arr2 и result (който е празен), като arr1 и arr2 са сортирани във възходящ ред. В края на функцията result трябва представлява обединение на 2-та масива и е сортиран във възходящ ред.

**Пример:**
```c++
[1, 5, 7, 8]
[2, 3, 9]
```
```c++
[1, 2, 3, 5, 7, 8, 9]
```

### **8.** Да се напишат функции, които приемат 3 масива от цели числа - **arr1**, **arr2** и **result** (който е празен) и пълнят третия съответно с обединението на **arr1** и **arr2**. **result** да е сортиран във възходящ ред.
Вход:

```
[2 4 1 7 8]
[1 2 3 5]
```

Изход:

```
[ 1 2 3 4 5 7 8 ]

```

### **9.** Да се напише функция, която приема 3 масива от цели числа - **arr1**, **arr2** и **result** (който е празен). В края на функцията **result** представлява сечението на 2-та масива и е сортиран във възходящ ред.

**Пример:**

Вход:

```
[2 4 1 3 7 8]
[1 2 3 5]
```

Изход:

```
[ 1 2 3 ]
```
