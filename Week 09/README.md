# Указатели и референции. Работа с масиви. Символни низове.

<slidebreak/>

## Референции
- Трябва да се инициализират при декларация
- След като веднъж е била инициализирана, повече не може да се променя

```cpp
// Променливите x и y сочат на едно и също място в паметта
int x = 42;
int& y = x;
y++;
std::cout << x << " " << y; //43 43

// int& z;  - Error

// Тук за променливата b се заделя нова памет и се копира стойността на a
int a = 42;
int b = a;
```

- Референции като аргументи на функции
- Референции като резултат на функция - само ако знаем, че променливата е жива след функцията

<slidebreak/>

## Указатели
- Указателят е променлива, която пази адрес от паметта - шестнадесетично число, пазещо поредния номер в паметта на първата клетка от променливата
- Създаваме указател от даден тип като след типа сложим `*`

```cpp
int* pointer = 0x123;
```

- Префиксен оператор `&`, приложен на променлива - връща нейния адрес
- Префиксен оператор `*`, приложен на променлива-указател - връща стойността, намираща се на този адрес, като взима предвид типа на указателя(колко байта да прочете) - операцита се нарича дереференсиране на указател

```cpp
int x = 42;
int* xAddress = &x; //0x...
int xValue = *xAddress; // 42
```

<slidebreak/>

```cpp
// Променливата y има за стойност някакво число - адрес
// Стойността на y е адресът на променливата x
int x = 42;
int* y = &x;
(*y)++;
std::cout << x << " " << (*y); //43 43
```

<slidebreak/>

- Указател може да има стойност `nullptr` (предефинирана константа от тип указател) - това е нулевият адрес в паметта, който не пренадлежи на никоя програма - използва се за невалидна стойност на указател

```cpp
int temp = 0;
int x = 42;

int *x1 = &x;
*x1 = 7;
x1 = &temp;

const int *x2 = &x; // same as int const *x1
// *x2 = 7;
x2 = &temp;

int *const x3 = &x;
*x3 = 7;
// x3 = &temp;

const int *const x4 = &x;
// *x4 = 7;
// x4 = &temp;
```

<slidebreak/>
- `void*` - пойнтър без тип - пази само адреса, не може да се ползва за нищо без да се кастне
- Защо всъщност указателите имат тип, ако сам пазят адрес? - За да може да извършваме адресна аритметика

```cpp
int x = 42;

int* xAddress = &x; // address n
xAddress++; // address n + sizeof(int)
```

<slidebreak/>

## Указатели и масиви
- Когато имаме масив, ние имаме указател към първия елемент от масива
- Масивът е последователност в паметта
- Следователно можем с адресна аритметика да достъпваме елементите на масива - така работи оператор `[]`

```cpp
int arr[10] = {1,2,3};
arr[0] = 7;
std:: cout << arr[0]; // 7

*arr = 8;
std::cout << *arr; // 8

*(arr + 1) = 9;
std::cout << *(arr + 1); // 9

// 8 9 3
```

<slidebreak/>

`arr[n] = *(arr + n)`

> [!IMPORTANT]
> Оператор `[]` ни позволява да достъпваме паметта с отместване и нищо повече. Когато имаме масив го интерпретираме като индекс на масива. Ако го прилагаме над произволна променлива, то се случва същото като при масива - отиваме надясно, просто паметта вече не знаем каква е.

<slidebreak/>

- Указател към указател - това е сценарият при матриците. По ООП се ползва и с други цели

```cpp
int x = 42;
int* xp = &x;
int** ptr = &xp;
(**xp)++; // x = 43
(*xp)++;  // xp value changed

// Матрицата в паметта е разгърната като една последователност
int matrix[5][5];
int* const* const mAddress = matrix;
int* arrM = matrix[1];
```

<slidebreak/>

## Символни низове

- Символният низ е последователност от символи
- Низът задължително завършва с един допълнителен символ - терминираща нула `'\0'`
- Последователност от 0 символа (без терминираща нула) наричаме празен низ
- Терминиращата нула е отделен символ и заема място, въпреки, че не я считаме за част от самото съдържание на низа
- Низовите константи (напр. `"Hello"`) представляват масив от символи завършващ с терминираща нула
- Терминиращата нула ни показва края на низа

```cpp
char word[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
char word[6] = { 'H', 'e', 'l', 'l', 'o' }; //обикновен масив от символи
char word[5] = { 'H', 'e', 'l', 'l', 'o' }; //обикновен масив от символи
char word[100] = "Hello";
char word[5] = "Hello"; //невалидно, понеже " "включват в себе си '\0'
char word[6] = "Hello";
char word[6]= {'H', 'e', 'l', 'l','\0', 'o'}; //символният низ е "Hell"
```

> [!IMPORTANT]
> Символният низ е интерпретация на масива от символи. Ако в даден символен масив имаме терминираща нула, от нас зависи дали го интерпретираме като низ или като последователност от символи. Терминираща нула може да има на средата на масив.

<slidebreak/>

- При работа с низове не е необходимо да знаем размера на масива, понеже интерпретацията на низ задължава съществуването на терминираща нула и съответно знаем кой е последният символ на низа
- По тази логика работи и `std::cout` - спира итерирането през символния масив когато стигне терминиращата нула на низа. Такава ТРЯБВА да има ако е низ!
- `std::cin` чете символен низ до срещане на табулация, интервал, символ за нов ред или край на потока
- Автоматично се добавя терминираща нула при четене

```cpp
int main() {
    char buffer[24];
    std::cin >> buffer; // Hello, world!
    std::cout << buffer << std::endl; // Hello, 
}
```

<slidebreak/>

- Ако искаме да имаме по-голям контрол над четенето, ползваме `std::cin.getline(char buffer[], size_t count, char delimiter = '\n')`;
- Буферът трябва да е предварително заделен и да укажем неговият размер. Може да използваме и различен символ за спиране на четенето
- Автоматично се добавя терминираща нула при четене

```cpp
#include<iostream>
// 13 characters + 1 for '\0' character
const int BUFFER_SIZE = 13 + 1;

int main() {
    char buffer[BUFFER_SIZE];
    std::cin.getline(buffer, BUFFER_SIZE); // Hello, world!
    std::cout << buffer << std::endl; // Hello, world!
}
```

> [!NOTE]
> Максималния брой символи които ефективно може да прочетем са винаги с един по-малко от размера на масива

```cpp
char text[4];
std::cin.getline(text,4); // test
std::cout << text;        // tes
```