# Увод в програмирането. <br/> Типове данни, основни операции, вход и изход

<slidebreak/>

## Като за начало
- Програмиране - процес по създаване на компютърна програма
- Компютърна програма(софтуер) - поредица от инструкции, водещи до определен резултат(код, изразяващ даден алгориъм), които се разбират от компютърната единица - ядро
- Език за програмиране - език, предназначен за описване на инструкциите на даден алгоритъм
- C++ - императивен(инструкции за промяна на състоянието), <br/>процедурен(поредица от инструкции), <br/>обектно-ориентиран(композиции и модели),<br/>език от високо ниво(по-удобен за хората, отколкото за компютрите), <br/>с възможности на функционален език. <br/>Подходящ за разбиране работата на програмите в дълбочина. Предоставя изключително много възможности, но също позволява и да се застреляш сам в крака  

<slidebreak/>

## Как ще програмираме
- Интегрирани среди за разработка(IDE) - предоставят често използвани инструменти за разработката на софтуер. Това включва **debugger**, **auto-complete**, **compiler integration**, 3rd party integrations (Azure, Docker, **Git**). Текстов редактор? 
- Компилиране - превеждане на програмен език до машинен код - информацията за компютъра е поток от 1 и 0 - наличие и липса на напрежение - ток. Резултатът на процеса на компилация е създаването на изпълним файл (и други помощни файлове) от изходен код.
- Source code (изходен код, ...) файлове - хедърни(`.hpp`, ...) и имплементационни(`.cpp`, ...). Текст, без значение от разширението му (защо?), но важно от семантична гледна точка.
- Повече за процеса на компилация? Разлика с интерпретацията? (може би по-нататък)
- Разработваме конзолни приложения - работим едниствено с текст, без ГПИ
- Visual Studio 2022 + clang
- VSCode/CLion + gcc
- Windows / Linux / Mac
- C++ 20

> [!NOTE] 
> Има  някои минимални разлики в компилаторите, които не би трябвало да представляват интерес за курса

<slidebreak/>

## Още нещо

<slidespace></slidespace>

- git ([see more](<https://docs.github.com/en/get-started/getting-started-with-git>))
- метаезик на Бекус-Наур ([read more](<https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form>))
- Дискретни структури 1,2 ([study more](<https://juliedanneberg.com/wp-content/uploads/2021/02/Blog-I-believe-in-you-942x1024.jpg>))
- Byte vs bit vs data
- [cppreference.com](<https://en.cppreference.com/w/>) 

<slidebreak/>

## По същество вече
```cpp
#include<iostream>
using namespace std;

// Our first program
int main()
{
  cout << "Hello, world!";
  return 0;
}
```

- keywords - `using`, `namespace`, `int`, `return`   
- operators - `;`, `<<`
- literals - `"Hello, world!"`, `0`
- identifiers - `std`, `main`, `cout`
- syntax specifics - `( ... )`, `{ ... }`
- preprocessor directives - `#include<iostream>`
- comments - `// Our first program`

<slidebreak/>

## Я пак?

<slidespace></slidespace>

- Обиктовено имаме една команда на един ред
- Всяка команда завършва с `;` 
- Засега запомняме, че между отварящата и затварящата скоба на блока на главната функция е нашата програма - тоест инструкциите
- `main` *функцията* завършва по конвенция с `return 0;` - по-нататък за смисъла на това 

<slidebreak/>

## Предпроцесор

<slidespace></slidespace>

- Изпълнява специални инструкции преди да започне същинската компилация на програмата
- 'Подготвя' програмата за компилация
- Винаги започват в началото на реда с `#` и **НЕ** завършват с `;`
- Примери по-нататък - `include`, `pragma`, `define`, `if`, `ifndef`, etc...

<slidebreak/>

## Пространства от имена

<slidespace></slidespace>

- Подобно на фамилното име на човек, което групира дадена роднинска група от хора, така и пространството от имена групира дадени имена, за да се разпознават (същинската причина са колизиите - малко по-късно за тях)
- Основното пространство от имена на стандартните библиотеки е `std`
- Пространствата от имена, които се ползват може да се специфицират чрез `using namespace <пространство>;`
- Също така пред всяко име от пространството, което се ползва може да се специфицира пространство чрез scope resolution operator `::` (по-късно за това)

<slidebreak/>

## Коментари

Едноредови - всичко след `//` е коментар
```cpp
// Comment
code; // Всичко след двете наклонени е коментар и не е част от кода 
// Another comment 
```
Многоредови - обособени от `/*` и задължително затворени някъде с `*/`
```cpp
/* Comment on a single line */
<code>
/* Comment
on a multiple
lines
*/
<code> /* Всичко между отварящата и затварящата поредица за коментар, 
се интерпретира като такъв*/ <code>
```
- Предпроцесорът премахва коментарите от изходния код за компилация
- Обикновено ползваме само едноредови коментари, поставени над кода, който се коментира

<slidebreak/>

## Стандартен вход и изход

<slidespace></slidespace>

- Операции по вход - четене - например четем написаното от клавиатурата
- Операции по изход - писанe - например пишем на конзолата
- Операциите по вход и изход се извършват под абстракцията на поредица от байтове, обособени в потоци (streams)
- Има стандартни потоци за четене, писане и грешки(специален поток за писане) - номерирани съответно с 0, 1, 2

<slidebreak/>

- В C++ това са съответно обектите от пространството на имена `std`:
  - `cin` - стандартен поток за четене (по подразбиране от конзолата, но не задължително). Понеже искаме да четем от него, тоест взимаме информация от потока, то използваме оператор `>>`. Тоест имаме `cin >> <variable>`.
  - `cout` - стандартен поток за писане (по подразбиране на конзолата, но не задължително). Понеже искаме да пишем в него, тоест подаваме информация към потока, то използваме оператор `<<`. Тоест имаме `cout << <variable | literal>`.
  - `cerr` - стандартен поток за грешки. Аналогична употреба със `cout` - има само семантична разлика! 
- Те са част от библиотеката (код, написан от някой друг и предоставен за използване) `iostream`.
- За библиотеките: Има системни библиотеки, които се добавят с предпроцесорната директива `#include` и се пишат в `<` и `>`, докато нашите библиотеки се добавят с кавички `"`, но те са за доста по-нататък. Тук предпроцесорната директива `include` буквално взима съдържанието на специфицирания файл и за слага на мястото на директивата, за да може да се компилира и той

<slidebreak/>

## Типове данни 
- Устройство на паметта(оперативна vs съхранение) - 'безкрайна' последователност от байтове
- Избираме си парче, върху което да запишем някакви данни
- Бройни системи - двоична бройна система - превръщане между бройни системи, азбуки, семантика (допълнително да обясним?)
- Булеви операции (ДСТР in advance) - ALU basics - bitwise - sum, AND, OR, etc.. 
- Повече за регистри и работа на паметта и процесора, endianess?

- Примитивни и съставни типове
- Управление на паметта
- Множество от допустими стойности

<slidebreak/>

- Някои основни примитивни типове (повече по-нататък)
  - Цели числа - `int`
  - Числа с плаваща запетая - `double`, `float`
  - Булеви стойности - `bool`
  - Символи - `char`
- Целите числа имат модификатори за големина (по подразбиране нямат) - `short`, `long`, `long long` и модификатори за знак - `signed`(по подразбиране, не се пише експлицитно), `unsigned`
- Модификатори за знак имат също символите (малко по-нататък ще обясним защо това реално има логика)
- Модификатор `long` има и типът `double`.
- Модификаторите на целите числа позволяват да се използват самостоятелно без да се опоменава типа `int`, като той се подразбира

- Всички тези типове и модификатори са keywords в контекста на C++

<slidebreak/>

### Размери

|Тип|Размер*<br>bytes(bits)|Допустими стойности|Аналогични типове**| Забележка|
|:---: |:---: |:---: |:---: |:---: |
|short|2(16)|$[-2^{15};2^{15}-1] \bigcap \mathbb{Z}$|`int16_t` |
|int|4(32)|$[-2^{31};2^{31}-1] \bigcap \mathbb{Z}$|`int32_t` |
|long|4(32)|$[-2^{31};2^{31}-1] \bigcap \mathbb{Z}$|`int32_t` |
|long long|8(64)|$[-2^{63};2^{63}-1] \bigcap \mathbb{Z}$|`int64_t` |
|unsigned short|2(16)|$[0;2^{16}-1] \bigcap \mathbb{Z}$|`uint16_t` |
|unsigned|4(32)|$[0;2^{32}-1] \bigcap \mathbb{Z}$|`uint32_t` |
|unsigned long|4(32)|$[0;2^{32}-1] \bigcap \mathbb{Z}$|`uint32_t` |
|unsigned long long|8(64) |$[0;2^{64}-1] \bigcap \mathbb{Z}$ |`uint64_t` |`size_t`***|

- *Откъде идва степента и откъде идва това -1 ?*

<slidebreak/>

|Тип|Размер*<br>bytes(bits)|Допустими стойности|Аналогични типове**| Забележка|
|:---: |:---: |:---: |:---: |:---: |
|float|4(32)|$[{3.4 \cdot 10^{-38}}; {3.4 \cdot 10^{38}}] \bigcap \mathbb{R}$|*|
|double|8(64)|$[{1.7 \cdot 10^{-308}}; {1.7 \cdot 10^{308}}] \bigcap \mathbb{R}$|-|
|long double|8(64)|$[{1.7 \cdot 10^{-308}}; {1.7 \cdot 10^{308}}] \bigcap \mathbb{R}$|-|
|char|1(8)|$[-127, 128] \bigcap \mathbb{Z}$|`int8_t`| `wchar_t`(16)****|
|unsgined char|1(8)|$[0; 255] \bigcap \mathbb{Z}$|`uint8_t`,`char8_t`|`char16_t`, `char32_t`|
|bool|1(8)|$\{0,1\}$|-||


- *Защо при float и double не работи зависимостта със степента ?*
- *Необходим ли е цял 1 byte за bool?*

<slidebreak/>

- \* Размери според стандарта за C++, да се чете 'поне', отговаря за x86 архитектура
- \** Дефинирани в `<cstdint>` и по-принцип носят по-добра четимост на кода, без да оставят интерпретацията на големината на типа на компилатора. За нашите нужди по-скоро няма да ги ползваме. Придържаме се максимално към най-подходящия тип за нашите цели според домейна на контекста на променливите, които създаваме.
- \*** - Обикновено `typedef unsigned long long size_t;` (какво е typedef?). Тип, даващ възможност за съхранение на всяка стойност на индекс на масив (по-нататък подробност)
- \**** - Адаптивен тип, предназначен за поддържане на надмножества на ASCII - UTF стандарти. Заради особености на Windows е ограничен до 16 бита и се поддържа точно Unicode code-point.

<slidebreak/>

- Оператор `sizeof(<тип>)` - връща размера на тип в байтове
- В `<cstdint>` има дефинирани константи 
  - за НГС на тип с фиксирани битове: `INT8_MAX`, `INT16_MAX`, ... `UINT16_MAX`
  - за НМС на тип с фиксирани битове: `INT8_MIN`, `INT16_MIN`, ... `UINT16_MIN`
- В `<climits>` има дефинирани константи за основните типове, които са с адекватни стойности спрямо архитектурата и компилатора
  - `CHAR_MIN` - `CHAR_MAX` // `UCHAR_MIN` - `UCHAR_MAX`
  - `SHRT_MIN`, `INT_MIN`, `LONG_MIN`, `LLONG_MIN`, както и вариантите с префикс `U` и суфикс `MAX`

> [!NOTE]
> 1 == sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)

<slidebreak/>

## Литерали 
- Буквални стойности от даден фиксиран примитивен тип
- Няма как да се променят
- Видове
  - Цели числа - например `42`
    - Ако използваме литерала по този начин той се третира като от тип `int`. Може да ползваме комбинации от следните суфикси за да окажем различен тип, като подредбата няма значение:

    | Suffix | Modifier |
    |:---: |:---: |
    |`u`, `U`| unsigned|
    |`l`,`L`| long|
    |`ll`,`LL`| long long|

    Примери: `42ul`, `42lu`, `42l`, `42u`, `42ull`, `42llu`

 <slidebreak/>

  - Ако искаме да ползваме друга бройна система от десетичната(по подразбиране), C++ има вградено поддържане на следните префикси:

    <slidespace></slidespace>

    | Prefix | Numerical system base |
    |:---: |:---: |
    |`0b`| 2 |
    |`0`| 8 |
    |`0x`| 16 |

  <slidebreak/>

  - Дробни числа - например `42.42`
    - По подразбиране се третира като литерал от тип `double`
    - Ако искаме `float` ползваме суфикс `f` - например `42.42f`
    - Алтернативен (scientific) запис - `<double multiplier>e[sign]<power>`

      Пример: `1.7e2 = 170`, `0.5e-2 = 0.005`

  > [!IMPORTANT]
  > Десетичната запетая трябва на всички да е '.'

  <slidebreak/>

  - Символи - например `'a'`
    - Винаги точно 1 символ в единични кавички
    - Специални символи - не могат да съществуват буквално и имат специални кодове (ние разглеждаме) - например символът за нов ред се бележи с `'\n'`

    | Character | Meaning |
    |:---: |:---: |
    |`'\n'`|LF(line feed)|
    |`'\r'`|CR(carriage return)|
    |`'\0'`|NULL|
    |`\t`|Tab|
    |`'\\'`|\

    - Особености на новите редове в операционните системи и семантиката им

    - [ASCII table](<https://www.asciitable.com/>) - как представяме символите в паметта, там имаме само числа - чрез определен биективен mapping между числа и символи - най-простият е "аски таблица", която C++ използва за да съхранява символите

  <slidebreak/>

  - Булеви стойности - `true` или `false`
    - Семантично отговарят на 1 и 0 и цифровата имплементация носи същата стойност в паметта

  <slidebreak/>

  - Низове - например `"string"`
    - 0, 1 или повече символи в двойни кавички

  <slidespace></slidespace>

  > [!CAUTION]
  > string не е примитивен тип

<slidebreak/>

## Променливи

- Имат фиксиран тип, който не може да се промена
- Стойността им може да се променя многократно

- Декларация vs Дефиниция

  Деклaрация на променлива:
  ```cpp
  <тип> <име>; // Създаваме променлива със стойност по подразбиране
  // Задължително следващото място, на което използваме тази  променлива,
  // трябва да е в контекста на задаване на стойност
  ```

  Дефиниция на променлива:
  ```cpp
  <тип> <име> = <стойност>; // Създаваме променлива със зададена  стойност, при спазване на особеностите на оператор = 
  ```

- Например: `int x = 5;`
- Може да декларираме и дефинираме много променливи на един ред:
` int x=5, y, z=5; `

<slidebreak/>

## Именуване на променливи

<slidespace></slidespace>

- Case-sensitive
- Името е identifier в контекста на C++
- Първият символ на името на променливата може да е главна или малка латинска буква или долна черта
- Имената след първия символ могат да съдържат букви, цифри, долни черти
- Имената не могат да бъдат запазени думи(keywords)
- Имената не могат да съдържат интервали

> [!NOTE]
> В стандарта на C++ се позволява използването на Unicode символи в имената, което реално е непрактично и нелогично предвид практиката да се програмира на английски език и да се следват конвенции в именуването

<slidebreak/>

- Style guide:
  - Не трябва да пишем произволни имена на променливи, те трябва да са говорящи и да следват определени правила
  - Имената са последователност от залепени заедно думи - задължително на английски език, удовлетворяващи camelCase формат - първата буква на името е малка, всяка следваща първа буква на дума от името е голяма
    - Има и други формати - PascalCase, snake_case, kebab-case и т.н., но е хубаво да се придържаме към camelCase в този курс.
  - Имената са в общия случай комбинация от прилагателно и съществително (понеже показват смисъл на дадено число или символ), като за това няма ограничения
  - Имената не трябва да са много дълги, в общия случай до 2 думи. Ако станат повече от 4 думи - задължително сменяме
  - Булевите променливи задължително започват с глагол, най-често is, has или should, тъй като те показват наличие или липса на свойство
    - Те винаги се пишат в положителна форма, без отрицателни частици

  <slidebreak/>

  - Име на променлива, в което има 'And', вероятно може да се рефакторира. Подобни забележки до голяма степен може да направим и за думата 'With'. Но винаги има изключения!
  - Еднобуквените имена са логични само за означения на прости операции и за приети означения - например, ако имаме страни на правоъгълник е по-добре да ги кръстим `a` и `b`, отколкото `firstSide`, `secondSide`.
  - Не е важно толкова името да следна някакви правила, колкото да разберем смисъла на променливата като прочетем кода.
  - Добри имена са:
    
    ```cpp
    int age = 19;
    bool isCourseEngaging = false;
    double patienceLevel = 0.5;
    char symbol = 'X';
    ```

> [!NOTE]
> Рефакторирането е процес по промяна на кода с цел по-добра стилова и логическа издържаност.

<slidebreak/>

## Константи

<slidespace></slidespace>

- "Променливи", на които зададената веднъж стойност не може да се променя
- Могат само да се дефинират, не е възможна декларация

```cpp
const int X = 4;
int const Y = 2;
const int const Z = 0;
```

<slidebreak/>

> [!CAUTION]
> Not so simple...
>  - const applies to the thing left of it. If there is nothing on the left then it applies to the thing right of it.
- Това правило ще е изключително важно по-нататък, когато си играем с паметта с голи ръце
- На този етап, когато декларираме константи от примитивен тип предпочитаме синтаксиса `const <type> <identifier> = <value>;`
- Константите винаги пишем с CAPITALIZED_SNAKE_CASE
- Например:
  ```cpp
  const double PI = 3.14;
  const int MIN_AGE = 18;
  const short CORRECT_ANSWER = 42;
  const char NEW_LINE = '\n';
  ```

<slidebreak/>

## Style guide

<slidespace></slidespace>

- В кода не трябва да имаме магически числа 
- Магическо число е всяко число, което се ползва като литерал
- Числата литерали се ползват само за инициализация - тогава не са магически числа
- Всяко магическо число трябва да бъде изнесено в константа
- За числата 0 и 1 понякога съществуват изключения
- Булевите стойности се ползват като литерали
- Рядко би се наложило да ползваме литерал на символ, но по-скоро няма да има нужда да го изнасяме като константа
- Символните константи по-нататък ще видим как се изнасят, ако това е необходимо

<slidebreak/>

## Programming guide

<slidespace></slidespace>

- В общия случай искаме да ограничим домейна на използвания тип максимално много, за да покрива единствено нуждите ни
- По този начин постигаме оптимизация на ниво използвана памет
- Това не е наложително навсякъде и винаги да го правим, но е добра практика да не разхищаваме ресурси
- Задължително обаче използваме правилен тип - няма да използваме целочислен тип за индикатор, който трябва да е булев тип

<slidebreak/>

## Macros
- Друга алтернатива на константите са макросите
- Макросите са много по-мощни и могат да приемат всякакви стойности, не само на литерали, а на цели изрази код

```cpp
#define <identifier> <statement>
```
Например:
```cpp
#define PI 3.14
```

- Макросите са предпроцесорни директиви
- Навсякъде в кода където използваме името на макроса, буквално ще се замени с неговата стойност
- От една страна са по-бързи и служат за оптимизации (защо?), но от друга не позволяват дебъгване на кода 
- В този курс избягваме макросите, освен за много специални случаи, ако изобщо същестувуват

<slidebreak/>

## Typedef
- Имаме възможност да създаваме наши имена на предефинирани типове 

> [!WARNING]
> Това не означава създаване на нови типове (ще разгледаме по-нататък), а само ново име на нещо съществуващо. Буквално добавяме псевдоним в кода

- Това може да се постигне и с макро, но вече разбрахме проблемите, които то причинява

```cpp
typedef <type> <name>;
```

- Рядко бихме използвали това, най-вече за типове със шаблони, които за жалост не са предмет на този курс

Пример:
```cpp
typedef unsigned short int ushort;
// ...
ushort x = 42;
```

<slidebreak/>

## Scopes

- Когато декларираме *нещо*, то има определен обхват на видимост - scope, още "блок"
- Всеки блок се обособява от отваряща и затваряща скоба `{}` 
- Може да създаваме произволни scope-ове в кода по всяко време, но се ползва единствено със семантичен смисъл
- Има няколко нива 
  - Global - по подразбиране, когато не сме в никой scope, дефиниран от скоби. Тук не е добре да създаваме нищо, освен константи
  - Namespace - може да имаме много блокове с едно и също име
  ```cpp
  namespace myNamespace
  {
    // ...
  }
  ```
  - Local - обособен от текущите `{}`
  - Class - по ОПП
  - Statement - до края на блока на `for`,`if`,`while`, `switch` (другия път)
  - Function - до края на тялото на функцията (по-нататък)

<slidebreak/>

## Преобразуване между типовете

- Може да преобразуваме явно(explicit) и неявно(implicit)
- Преобразуването може да е със загуба на информация(lossy) или без загуба на информация(lossless)

- Явно преобразуване - explicit casting
  - C-style casting
  
  ```cpp
  (<type>)<expression>
  <type>(<expression>)
  ```

  - Други видове преобразуване в следващите курсове. Този вид cast-ване е композитен на няколко други типове и в общия случай ако преобразуването е възможно, то ще се случи, с малки изключения, които в този курс не ни засягат. Като минус може да отбележим, че грешката може да се случи чак runtime, а не compiletime, ако не е възможно преобразуване

  Пример:
  ```cpp
  int x = 42;
  double y = (double)x;
  ```

<slidebreak/>

- Неявно преобразуване
  - Компилаторът сам се досеща за преобразуващия тип от контекста
  
  Пример:
  ```cpp
  int x = 42;
  double y = x;
  ```

<slidebreak/>

- Преобразуване без загуба на информация
  - Widening conversions (promotion)
  - Когато типът, към който преобразуваме е семантично по-широк от типа, от който преобразуваме, т.е. имаме възможност за пълна инекция, която смислово задоволява преобразуващия тип
  - Все пак е логично да погледнем и дали множеството от стойности на типа, в който преобразуваме е надмножество на множеството от стойности на типа, от който преобразуваме, ако става въпрос за семантично еднакви типове, например цели числа
  - Разбира се, ако в дадения контекст знаем, че стойностите, които приема даден тип са фиксирани в определен диапазон, то горното съображение е безмислено и е достатъчно за нашия случай да може да преобразуваме без загуба на информация 

  <slidebreak/>
  
  Примери:
  ```cpp
  // Тук стойностите true и false еднозначно отговарят на числата 1 и 0 
  // за всеки целочислен тип, символен тип и тип за числа с плаваща запетая
  bool x = true;
  int y = x; // 1
  ```
  ```cpp
  // Тук домейнът на x е подмножество на домейнът на y
  int x = 42;
  double y = x; // 42.0
  ```
  ```cpp
  // Всеки символ отговаря на дадена стойност от ASCII таблицата
  char x = 'a';
  int y = x; // 97
  ```
  ```cpp
  // За произволни стойности на x преобразуването ще има загуба,
  // но за тази конкретна стойност, няма да има загуба
  unsigned long long x = 42;
  short y = x;
  ```

<slidebreak/>

- Преобразуване със загуба на информация
  - Narrowing conversions (coercion)
  - Новият тип няма как да побере стойността на променливата
  ```cpp
  // Тук домейнът на булевия тип е много по-малък и стойността 0 се превръща в 0(false),
  // а всички останали стойности в 1(true) 
  int x = 42;
  bool y = x; // true (1)
  ```
  ```cpp
  // Десетичните числа губят информацията след запетаята.
  double x = 42.42;
  int y = x; // 42
  ```
  ```cpp
  // Въпреки че променливите заемат еднаква памет, те имат
  // различен домейн и тук се взима предвид двоичната репрезентация
  // Two's complement
  unsigned short x = 65535; // in memory: 1111111111111111
  short y = x; // -1        // in memory: 1111111111111111
  ```
  ```cpp
  // Overflow - стойността 129 прелива от домейна на char и
  // започва да се пълни от долната граница наново
  int x = 129;
  char y = x; // -127
  // Аналогично за x=246 ще имаме y=-10
  ```

<slidebreak/>
 
## Oператори

<slidespace></slidespace>

- Всеки non-alphanumeric символ е оператор
- Има и оператори представляващи думи - sizeof, new, delete,throw, etc...
- Всеки оператор се характеризира с:
  - Приоритет - повече [тук](<https://en.cppreference.com/w/cpp/language/operator_precedence>)
  - Брой на аргументите - унарни, бинарни, тернарен
  - Разположение спрямо аргументите - инфиксен, префиксен, суфиксен
  - Асоциативност
- Нито една от тези характеристики не може да се променя, може да се променя единствено поведението на някои оператори(по-нататък)
- Приоритетък, както в математиката, може да контролираме донякъде със `()`

<slidebreak/>

## Values

<slidespace></slidespace>

- `lvalue` - нещо с адрес в паметта. Място, където може да се променя
  - Засега приемаме, че lvalue са променливите
- `rvalue` - нещо без адрес в паметта. Временна стойност
  - Засега приемаме, че rvalue са литералите
- Класификацията е по-сложна от това, но в общи линии lvalue и rvalue не са само отделни променливи или литерали, а цели изрази и техните резултати

<slidebreak/>

## Оператор за присвояване `=`

<slidespace></slidespace>

- Дясно-асоциативен, бинарен, инфиксен
- Връща lvalue
- Позволява chaining

```cpp
int a, b, c, d;

a = b = c = d = f = 4;
а = (b = (c = (d = (f = 4))));
```

> [!CAUTION]
> На оператор `=` вляво винаги стои само `lvalue`, вдясно може да стои както `lvalue`, така и `rvalue`

<slidebreak/>

## Аритметични оператори

| Оператор | Значение |
| :---: | :---: | 
| `+` | Събиране |
| `-` | Изваждане | 
| `*` | Умножение |
| `/` | Деление | 
| `%` | Деление с остатък |

- Оператор `%`
  - Може да се прилага едниствено върху целочислени типове данни и връща цяло число в интервала $[0;n-1]\cap\mathbb{Z}$ при операция `x % n` - защо?
  - Използва се най-често за проверка на делимост(`x % a`) и взимане на последната цифра от число(`x % 10`)
- Резултатът от операциите на другите оператори зависи от типа на аргументите

```cpp
 int x = 5 / 2;      // 2
 double y = 5.0 / 2; // 2.5
 int z = 5.0 / 2;    // 2.5 -> 2
```
<slidebreak/>

## Смесени оператори за присвояване

| Оператор | Значение |
| :---: | :---: | 
| `+=` | Събиране |
| `-=` | Изваждане | 
| `*=` | Умножение |
| `/=` | Деление | 
| `%=` | Деление с остатък |

- Инфиксни, бинарни
- Винаги връщат `lvalue`
- Левия аргумент трябва да е `lvalue`
- Извършват математическа операция и присвояване към левия аргумент
- `a += b` е еквивалентно на `a = a + b`

<slidebreak/>

## Логически оператори

<slidespace></slidespace>

| Оператор | Значение | Тип |
| :---: | :---: | :---: |
| `&&` | Логическо **и** | инфиксен, бинарен|
| `\|\|` | Логически **или** | инфиксен, бинарен|
| `!` | Логическо **не** | префиксен, унарен|

<slidespace></slidespace>

- Връщат винаги булев резултат - `rvalue`
- Ако аргументите им не са булеви - ще ги преобразуват имплицитно, ако това е възможно, иначе - грешка

<slidebreak/>

- Short-circuit оператори - `&&` и `||`: оценката на стойността на израза спира при наличие на ясен резултат. Това е възможно когато:
  - Имаме няколко израза, слепени с оператор `&&` - ако срещнем някъде стойност `false`, то целия израз ще е `false`
  - Имаме няколко израза, слепени с оператор `||` - ако срещнем някъде стойност `true`, то целия израз ще е `true`
- Приложението на short-circuit операторите ще видите в процеса на работата - най-вече са удобни за предотватяване на изпълнението на проверки или последваща оценка на изрази

<slidebreak/>

## Оператори за сравнение - релационни оператори

<slidespace></slidespace>

| Оператор | Значение |
| :---: | :---: |
| `<` | По-малко |
| `>` | По-голямо | 
| `<=` | По-малко или равно |
| `>=` | По-голямо или равно | 
| `==` | Равно на |
| `!=` | Не е равно на |

<slidespace></slidespace>

<slidebreak/>

- Бинарни, инфиксни
- Винаги връщат булев резултат
- За сравнение на числени стойности
- Ако аргументите им не са от числен тип, се прави неявно преобразуване към такъв (char, bool), в противен случай - грешка

> [!CAUTION]
> Никога не сравняваме променливи от тип `double` с `==`, поради грешки от закръгляване, заради естеството на паметта.

<slidebreak/>

> [!IMPORTANT]
> За числа от тип `double` проверяваме равенството като гледаме дали двете числа имат разлика най-много ${10^{-9}}$ едно от друго

 ```c++
#include <iostream>
#include <cmath>

const double EPSILON = 1e-9;

int main() 
{
    double a=0.3, b=0.2999999999999;
    // Засега използваме функцията fabs от библиотеката cmath
    bool areEqual = (std::fabs(a - b) < EPSILON);
    std::cout << areEqual;
}
```

<slidebreak/>

## Побитови оператори

| Оператор | Значение | Тип |
| :---: | :---: | :---: |
| `&` | Побитово **и** | инфиксен, бинарен|
| `\|` | Побитово **или** | инфиксен, бинарен|
| `~` | Побитово **не** | префиксен, унарен|
| `<<` | Побитове отместване наляво | инфиксен, бинарен|
| `>>` | Логическо отместване надясно | инфиксен, бинарен|


```cpp
int x = 7;     // 0b110
int y = 5;     // 0b101
int op1 = x&y; // 0b100
int op2 = x|y; // 0b111
int op3 = ~x;  // 0b001
int op4 = x<<2;// 0b11000
int op5 = x>>2;// 0b1__
```

<slidebreak/>

## Оператори ++ и --

- Унарни оператора

> [!CAUTION]
> И двата оператора могат да се ползват както като префиксни, така и като посфиксни

- Increment / decrement the value by 1

- Prefix връща `lvalue` - връща самата променлива след промяната на стойността с единица -  може да му се присвоява друго
- Postfix връща `rvalue` - връща стойността на променливата преди тя да се промени - не може да му се присвоява друго


```cpp
int a = 42;
int b = a++; // b=43, a=43
int c = ++a; // c=43, a=44

a++ += b // a=88
a++ = 5; // a=5
// ++a = 7; - WRONG
```

<slidebreak/>

## Тернарен оператор

<slidespace></slidespace>

Единственият тернарен оператор
```cpp
<condition> ? <expression 1> : <expression 2>
```
- Задължително двата израза трябва да са от еднакъв тип - иначе компилационна грешка
- Ако условието се оцени до истина, ще се върне стойността на първия израз, иначе - на втория
- Понеже има 3 операнда, приоритетът най-добре да го определяме експлицитно със скоби

```cpp
int a = 1 ? 2 : 3;   // a=2   - hard to read
int b = (0 ? 2 : 3); // b=3
int c = 5 + (5 < 4 ? 2 : 3); // c=8

std::cout << (a < b) ? a : b; // 1  - incorrent due to precedence
std::cout << (a < b ? a : b); // 2
```

<slidebreak/>

## Оператор sizeof

<slidespace></slidespace>

- Унарен, префиксен, използваме го със скоби
- Връща големината на променливата или на типа в байтове

<slidespace></slidespace>

```cpp
int x = 42;
int size1 = sizeof(x);  // 4?
int size2 = sizeof(int) // 4?
```

<slidebreak/>

## Оператори >> и << в контекста на <br/> входно-изходните операции
- Обектите `std::cin` и `std::cout` са си предефинирали поведението на побитовите операции съответно `>>` и `<<`
- Те позволяват chaining, понеже резултатът от прилагането на оператора е неговият ляв аргумент
- Операторите са ляво-асоциативни

```cpp
int x, y, z;

std::cin >> x >> y >> z;
(((std::cin >> x) >> y) >> z);


std::cout << x << y << z;
(((std::cout << x) << y) << z);
```  

<slidebreak/>

### Още малко

- `std::cin` чете информацията до whitespace (space(' '), tabulation('\t'), newline(?))
- Символът за нов ред в различните операционни системи
  - Windows: CRLF (`"\r\n"`)
  - Unix(Linux): LF (`"\n"`)
  - Mac: CR (`"\r"`), а след OS X: LF (`"\n"`)
- `\n` е достатъчен, потокът се оправя сам...
- `std::endl` - символ за нов ред '\n' - в допълнение flush-ва потока, тоест изписва насъбраният текст в буфера на екрана (повече информация за начина на работа?)
- Ако трябва да извлечете информация включително space/tabulation, трябва да използвате `getline`, `get`, etc. - функции от `iostream` в `std` пространството от имена - това за по-нататък

```cpp
std::cout << "Enter your age and height: ";
std::cin >> age >> height;
std::cout << "Your age is: "<< age << " and height: " << height << std::endl;
```

<slidebreak/>

### За финал

- *Най-безполезният оператор:* оператор `,`
- Позволява chaining и съответно оценка на няколко израза отляво надясно
- Връща стойността на последния израз

```cpp
int a = 7
int x = (42, a+8, a++, --a); // 7
```

<slidebreak/>

## Back to the beginning

```cpp
using namespace std;

int main()
{
  cout << "Hello, world!";
  return 0;
}
```

> [!TIP]
> Въпроси?