# Условни оператори и оператори за цикъл - затвърждаване.<br>Основни принципи при работа

<slidebreak/>

### Валидиране на входа

- При некоректни входни данни можем да изпишем грешка на `std::cerr`
- Можем да проверяваме състоянието на потока за четене, за да сме сигурни дали операцията е завършила успешно
    - `std::cin.fail()` - булева стойност, показваща дали последната операция е завършила с грешка
    - `std::cin.good()` - булева стойност показваща дали последната операцията е завършила с успех
    - `std::cin.bad()` - булева стойност, показваща дали някоя операция е завършила с грешка
    - `std::cin.clear()` - изчиства състоянието на потока
    - `!std::cin` - имплицитно се преобразува към тип `bool`, еквивалентно на `std::cin.fail()`, също на `!std::good()`

<slidebreak/>

- При наличие на некоректни данни може да приключим програмата преждевременно с `return <status code>;`. Кодовете за изход са:  
    - `0` - за успех, стандартно така завършва `main` функцията 
    - Всеки друг положителен код означава, че програмата завършва с грешка
    - За семантично различни грешки се ползват обикновено различни кодове
- Ако искаме програмата да приклячи успешно и просто да принтира грешката на стандартния изход (не на изхода за грешки), то това е валиден случай, всичко зависи от контекста

<slidebreak/>

- Guard clause - проверка с обърнато условие, която предотвратява нататъчното изпълнение на кода (Защо обърнато условие?)

```cpp
const int MIN_VALUE = 5;
const int MAX_VALUE = 10;
int number;
std::cin >> number;
if (!std::cin)
{
	std::cerr << "You should enter a number" << std::endl;
	return 1;
}

if(x < MIN_VALUE || x > MAX_VALUE)
{
    std::cerr << "The number must be between "<< MIN_VALUE<< " and "<< MAX_VALUE << std::endl;
	return 2;
}

// More code
```

<slidebreak/>

### Оптимизация на дървото на разклоненията

- Случаите, които водят до еднакъв резултат, при нормални обстоятелства, искаме да са събрани заедно, за да избегнем повторението на код

```cpp
// Code breaking guides
int year;
std::cin >> year;
if (year % 4 == 0)
{
	if (year % 100 == 0)
	{
		if (year % 400 == 0)
		{
			cout << "Leap Year";
		}
		else
		{
			cout << "Normal Year";
		}
	}
	else
	{
		cout << "Leap Year";
	}
}
else
{
	cout << "Normal Year";
}
```

```cpp
// Code following guides
int year;
std::cin >> year;
if (year % 4 == 0 && ((year % 100 != 0) || year % 400 == 0))
{
	cout << "Leap Year";
}
else
{
	cout << "Normal Year";
}
```

<slidebreak/>

### Магически числа и преобразуване на символи

- Всяко число различно то `0` и `1` трябва да бъде изнесено като константа
- Когато правим проверки за символи, никога не ползваме техните числени стойности от ASCII таблицата, а ползваме символните литерали - така избягваме нуждата от константи
- За преобразуване от малка в голяма буква и обратно, както и от символ цифра в числена стойност, е необходимо да приложим правилата за mapping на интервал в друг (от математиката):
    - От малка в голяма буква: `c + 'A' - 'a'`
    - От голяма в малка буква: `c + 'a' - 'A'`
    - От цифра в числена стойност: `c - '0'`
    - От числена стойност в цифра: `c + '0'`

<slidebreak/>

```cpp
// Code breaking guides
char character;
std::cin >> character;
if (character >= 65 && character <= 90)
{
	if (character == 'A' || character == 'E' || character == 'U' || character == 'O' || character == 'Y')
	{
		std::cout << "Vowel" << endl;
	}
	else
	{
		std::cout << "Not Vowel" << endl;
	}
	std::cout << "Capital Letter" << endl;
	char newCharacter = character + 32;
	std::cout << newCharacter;
}
```

<slidebreak/>

### Използване на имена от `std`

- Не е добра практика да ползваме `using namespace std;` от към качество на кода
- От тук нататък този ред е забранен
- Стараем се да пишем винаги `std::cin`, `std::cout`, ...

<slidebreak/>

### Използване на правилен тип данни

- Трябва винаги да внимаване дали използваме правилен тип данни спрямо контекста на задачата

```cpp
// Code breaking guides
std::cin >> a >> b >> c;
int D = b * b - 4 * a * c;
if (D > 0)
	cout << "2 roots";
else if (D == 0)
	cout << "1 doubled root";
else
	cout << "0 roots";
```

<slidebreak/>

### Сравняване на дробни числа

- Когато искаме да ползваме дробни числа, винаги предпочитаме `double`
- Винаги когато сравняваме дробни числа, използваме някаква фиксирана грешка и **НИКОГА** `==`

```cpp
const double EPSILON = 1e-9;
double x = 0.1 + 0.2;
double y = 0.3;
std::cout << x << std::endl;                                           // 0.3
std::cout << y << std::endl;                                           // 0.3
std::cout << (x == y) << std::endl;                                    // false
std::cout << (x - y) << std::endl;                                     // 5.55112e-17
std::cout << (x < y ? y - x < EPSILON : y - x < EPSILON) << std::endl; // true
```

<slidebreak/>

```cpp
// Code breaking guides
double a, b, c;
std::cin >> a >> b >> c;
if (c < b && c > a)
	std::cout << "in the interval";
if (c == a || c == b)
	std::cout << "in the closed interval";
else
	std::cout << "not in the interval";
```

<slidebreak/>

### Четене от стандартния вход

- Може да имаме случай на четене от стандартния вход на неизвестен брой данни 
- Ако искаме да прочетем всички данни до тяхното изчерпване:

```cpp
int num;
int sum = 0;
while(std::cin >> num)
{
    sum += num;
}

std::cout << sum;
```

- Това е удобно при четене от поток при пренасочване, например от файл
- Ако искаме да тестваме от входа от конзолата, то за да подадем сигнал за край на входа може да ползваме `Ctrl + Z`

<slidebreak/>

### Операции с цифрите на число

- Когато имаме дадено цяло число, можем да правим всякакви операции с цифрите му, например:
    - Да търсим сума или произведение
    - Да търсим цифри на определени позиции
    - Да търсим числото с обърнати цифри 
    - Да търсим брой срещания
    - Много други...

- Основна операция е взимането на $k$-тата поредна цифра отпред и отзад на числото $x$, което е $n$-цифрено
    - `x / pow(10,n - k) % 10` - отпред назад
    - `x / pow(10,k - 1) % 10` - отзад напред

<slidebreak/>

- Може итеративно да обхождаме цифрите отзад напред - най-честия случай

```cpp
int n;
std::cin >> n;
while(n != 0)
{
    int d = n % 10;
    // ... operation with digit d
    n /= 10;
}
```

- Mutate vs non-mutable n

<slidebreak/>

### Подходящ оператор за цикъл

- Ако проверяваме за зависими помежду си стойности в определен диапазон - `for`
- Ако знаем само как да конструираме условие за финал - `while`
- Ако не знаем нищо - `while` 

<slidebreak/>

### Процеси, основани на циклични проверки

- Проверка за просто число
- Проверка за НОК и НОД
- Разлагане на число на множители
- Факториел
- Парциални суми
- Ред на Фибоначи

<slidebreak/>

### Вложени цикли
- Геометрични фигури
- Декартово произведение
- Матрици
